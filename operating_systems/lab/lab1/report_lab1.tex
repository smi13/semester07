\include{preamble}

\begin{document}

\input{./title.tex}

\renewcommand{\cftsecleader}{\cftdotfill{\cftsubsecdotsep}}

\onecolumn

\textbf{Формулировка задания (1.6):}  Напишите скрипт, управляющий списком текущих дел. Скрипт должен хранить
     список дел в файле .todo в текущем каталоге и предоставлять возможность
     добавления задачи, удаления задачи, отметки задачи как выполненной и
     просмотра всех задач. Режим работы задается параметром командной строки.
     Предусмотрите также параметр, при использовании которого скрипт будет
     работать с файлом .todo в домашнем каталоге пользователя независимо от
     наличия файла .todo в текущем каталоге. Все скрипты должны выдавать справку о своем назначении и поддерживаемых параметрах
     командной строки. Справка печатается на экран, если среди параметров есть ключ
     «--help» или «-h», никаких других действий в этом случае выполнять не нужно. \\

\textbf{Реализация:} На языке оболочки \textsc{bash}. Первая реализация скрипта существенно отличалась от приведенной ниже.
Для удаления задания, добавления нового, а также отметки выполненного задания использовались \textsc{awk} и \textsc{sed}. Для подсчета
строк использовались \textsc{wc} и \textsc{tr}, также возможно использования \textsc{wc} и \textsc{cut}. Для вывода списка задания - 
\textsc{cat}. Камнем преткновения стало то, что мне удалось реализовать задуманную пометку выполненного задания - дописывание в конец 
строки слова (done), приведенные средства всегда добавляли слово после перевода строки. В итоге я решил отказаться вообще от использования
специальных команд, а реализовать задание на ``чистом'' \textsc{bash}. \\ 

\noindent В начале работы скрипта файл загружается в массив построчно, в конце -
этот массив сбрасыватся в файл (\textit{.todo} или \textit{ \ensuremath{\sim}/.todo} в зависимости от режима работы скрипта). Ясно, что при таком подходе, 
во-первых, нет нужды хранить номера заданий - их можно просто дописать при выводе массива в файл (также отпадает необходимость перенумеровывать задания
идущие вслед за удаляемым), а во-вторых все необходимые функции реализуются наиболее прозрачно. Добавить строку (done)? 
Просто сконкатенировать две строки. Как удалить конкретное задание? Выполнить команду \textsc{unset}, а затем учесть это при выводе. Вывести на 
экран? Тривиальный цикл.


\section*{Исходный код скрипта}
\lstset{language=bash, caption=taskmgr.sh,%
label=source-code, basicstyle=\footnotesize,%
numbers=left, numberstyle=\footnotesize, numbersep=5pt, frame=single, breaklines=true, breakatwhitespace=false,%
inputencoding=utf8x}
\lstinputlisting{taskmgr.sh}

\end{document}

